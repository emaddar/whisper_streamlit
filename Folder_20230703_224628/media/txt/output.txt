 In the beginning stages of your data science project, you see dependency management tools like people or conda, maybe sufficient. However, as a data science project expands, the number of dependencies also increases. This can make it difficult to reproduce the project's environment when relying solely on people or conda. To address these challenges, poultry, an open source library provides a powerful tool for creating and maintaining Python projects. In this video, we will delve into the advantages of poultry and halalach, its key distinctions from PIP and conda, having a broad selection of packages, messet easier for developers to find the specific package that messwed their needs. Conda has a limited number of packages. Some packages, like SNS-grade, cannot be installed with conda, additionally, certain versions, such as pandas to log all, might not be available for installation through conda. While you can use PIP inside a conda virtual environment, conda cannot track dependencies installed with PIP, making dependency management challenging. PIP and poultry can install any packages from the Python package index and other repositories. Reducing the number of dependencies, simplifies the development process. Conda provides full environment isolation, managing both Python packages and system-level dependencies. This can result in larger package size compared to other package managers. To illustrate this, we will install pandas in a new conda environment, and list all packages installed in this environment. We can see that a lot of these packages are not pandas dependencies. PIP and poultry install only the dependencies required by a package. On installing packages and their dependencies pre-up disk space and prevents unnecessary clutter. PIP removes only the specified package, not its dependencies potentially leading to the accumulation of unused dependencies over time. Conda removes the package and some of its dependencies, but not our dependencies. Poetry removes a package and all of its dependencies. Dependency files specifies the exact versions, all versions ranges of required packages. To save dependencies in a conda environment, you need to manually write them to a file. Let's assume that we are using pandas version 1.3.1. If a new user tries to reproduce environment, when the latest versions of pandas is 1.5.3, pandas 1.5.3 will be installed instead. If the code may rely on syntax, specific to pandas versions 1.3.1, and the syntax has changed in versions 1.5.3, running the code with the new version of pandas would introduce bugs. The same problem can occur with PIP. Imagine the requirements docteersc file looks like this. Now let's create an activate a virtual environment and install dependencies from the requirements doctersc file. You can see that pandas 2.0 is installed. Of course, you can ping down the version by freezing them in a requirements doctersc file. However, this mess the code environment lacks flexible and potentially harder to maintain in the long run. Any changes to the dependencies would require manual modification in the requirements doctersc file, which can be time consuming an error prompt. Poetry automatically updates the PIP project docter file where the installing a package. This flexible versioning approach ensures that your project can adapt to newer releases with our manual adjustment. The Poetry docter file store the precise version numbers for each package and its dependencies. This guarantee consistency in the installed packages. Here we can see that pandas 1.5.3 is installed instead of pandas 2.0. By separating the dependencies, you can clearly distinguish between the packages required for development purposes from the packages needed for the production environment. This ensures that the production environment contains only the necessary packages for running the application, producing the risk of conflicts. Pandas doesn't inherently support separate delivery.  dependencies for different environments. Both a workaround involves creating two environment files, one for the production environment and one for development. The development file contains both production and development dependencies. Deep also does and directly support separate dependencies, but a similar approach can be used with separate requirement files. To install the production dependencies type, clip install requirements.txt. To install most types of requirements, type, clip install requirements, depth.txt. Poetry simplifies managing dependencies by supporting groups within one file. To illustrate this, we will add number pie and pandas to the main group and pie tests and pre-commit to the development group. We can see that both groups of dependencies are added to the pie project.time file. This allows you to keep track of all dependencies in a single place. To install only production dependencies, type, poetry install only men. To install most development and production dependencies, type, poetry install. Obbeding dependencies is essential to benefit from workplaces and new features introduced in newer package versions. Condor allows you to update only a specified package. For example, if we want to update pandas poles and cycle run, we need to run the command, condor update for each package. Afterwards, you need to manually update the environment.yammo file. To keep its sync with the updated dependencies, people also only allow you to update a specified package and requires you to manually update the requirements.timest file. With poetry, you can use the update command to upgrade our packages, specified in the priproject.time file. This action automatically updates the poetry.lof file ensuring consistency between the package specifications and the log file. dependency conflicts occurred when packages required by a project have conflicting dependencies. Feed install packages so casually, which means it installs each package one by one. For example, suppose you install pandas to the old doc2, which requires number pie greater than or equal to one doc20.c. Later, you install number pie, equal to one doc20.c.timest file. Even though this will create dependency conflicts, tip will proceed to update the version of number pie. Condor uses a S80 server to explore our combinations of package versions and dependencies for instance. If an existing package has a specific constraint for its dependency, and the package you want to install does a mid-dry requirement. Condor want immediately raise an error, instead it will deligion to leave such for compatible versions of other required packages and their dependencies. Only reporting an error if no suitable solution is found. While this approach enhances the chances of finding a solution, it can be computationally intensive, particularly when dealing with extensive environments. By focusing on the direct dependencies of the project, poultry's deterministic resolver narrow-scout the search space. It evaluates the specified constraints and immediately identifies any conflicts. To demonstrate this, let's install a specific version of C-borne, that requires match plot-leap version 3.1 or HIGHGLE. If we attempt to install a version of match plot-leap, that falls outside of this required range, C-borne will promptly flow an error. This immediate feedback allows developers to address the problem early in the development process. For example, in this case, we can relax a requirement for C-borne to enable the installation of a specific version of match plot-leap. In summary, poultry provides several advantages over PIP and Condor. Firstly, poultry provides access to a wide range of packages. Secondly, poultry installs only the necessary dependencies, thirdly poultry simplifies the removal of packages and their dependencies. Lastly, poultry efficiently resolves dependencies and addresses any conflicts promptly. Efficient dependency management, adjust the initial step in constructing a maintainable data science project. To ensure long-term maintainable data science project,  it is crucial to avoid hard coding. In this next video, you will learn how to use a configuration file to eliminate hard coding in your next Python project. 